{
  "name": "dox",
  "description": "Markdown / JSdoc documentation generator",
  "version": "0.7.0",
  "author": {
    "name": "TJ Holowaychuk",
    "email": "tj@vision-media.ca"
  },
  "contributors": [
    {
      "name": "Jarvis Badgley",
      "email": "chiper@chipersoft.com"
    },
    {
      "name": "Arseny Zarechnev",
      "email": "me@evindor.com"
    },
    {
      "name": "Thomas Parisot",
      "email": "hi@oncletom.io"
    },
    {
      "name": "Stephen Mathieson",
      "email": "me@stephenmathieson.com"
    },
    {
      "name": "Vladimir Tsvang",
      "email": "vtsvang@gmail.com"
    },
    {
      "name": "Nathan Rajlich",
      "email": "nathan@tootallnate.net"
    },
    {
      "name": "Gion Kunz",
      "email": "gion.kunz@gmail.com"
    },
    {
      "name": "ForbesLindesay"
    }
  ],
  "homepage": "https://github.com/tj/dox",
  "repository": {
    "type": "git",
    "url": "git://github.com/visionmedia/dox.git"
  },
  "keywords": [
    "documentation",
    "docs",
    "markdown",
    "jsdoc"
  ],
  "bin": {
    "dox": "./bin/dox"
  },
  "dependencies": {
    "commander": "~2.7.1",
    "jsdoctypeparser": "^1.1.4",
    "marked": ">=0.3.1"
  },
  "devDependencies": {
    "mocha": "~2.2.1",
    "should": "~5.2.0"
  },
  "scripts": {
    "test": "make test"
  },
  "readme": "# Dox\n[![Build Status](https://travis-ci.org/tj/dox.svg?branch=master)](https://travis-ci.org/tj/dox)\n\n Dox is a JavaScript documentation generator written with [node](http://nodejs.org). Dox no longer generates an opinionated structure or style for your docs, it simply gives you a JSON representation, allowing you to use _markdown_ and _JSDoc_-style tags.\n\n## Installation\n\nInstall from npm:\n\n    $ npm install -g dox\n\n## Usage Examples\n\n`dox(1)` operates over stdio:\n\n    $ dox < utils.js\n    ...JSON...\n\n to inspect the generated data you can use the `--debug` flag, which is easier to read than the JSON output:\n\n     $ dox --debug < utils.js\n\nutils.js:\n\n```js\n/**\n * Escape the given `html`.\n *\n * @example\n *     utils.escape('<script></script>')\n *     // => '&lt;script&gt;&lt;/script&gt;'\n *\n * @param {String} html string to be escaped\n * @return {String} escaped html\n * @api public\n */\n\nexports.escape = function(html){\n  return String(html)\n    .replace(/&(?!\\w+;)/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n};\n```\n\noutput:\n\n```json\n[\n  {\n    \"tags\": [\n      {\n        \"type\": \"example\",\n        \"string\": \"    utils.escape('<script></script>')\\n    // => '&lt;script&gt;&lt;/script&gt;'\",\n        \"html\": \"<pre><code>utils.escape(&#39;&lt;script&gt;&lt;/script&gt;&#39;)\\n// =&gt; &#39;&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;&#39;\\n</code></pre>\"\n      },\n      {\n        \"type\": \"param\",\n        \"string\": \"{String} html string to be escaped\",\n        \"types\": [\n          \"String\"\n        ],\n        \"name\": \"html\",\n        \"description\": \"string to be escaped\"\n      },\n      {\n        \"type\": \"return\",\n        \"string\": \"{String} escaped html\",\n        \"types\": [\n          \"String\"\n        ],\n        \"description\": \"escaped html\"\n      },\n      {\n        \"type\": \"api\",\n        \"string\": \"public\",\n        \"visibility\": \"public\"\n      }\n    ],\n    \"description\": {\n      \"full\": \"<p>Escape the given <code>html</code>.</p>\",\n      \"summary\": \"<p>Escape the given <code>html</code>.</p>\",\n      \"body\": \"\"\n    },\n    \"isPrivate\": false,\n    \"ignore\": false,\n    \"code\": \"exports.escape = function(html){\\n  return String(html)\\n    .replace(/&(?!\\\\w+;)/g, '&amp;')\\n    .replace(/</g, '&lt;')\\n    .replace(/>/g, '&gt;');\\n};\",\n    \"ctx\": {\n      \"type\": \"method\",\n      \"receiver\": \"exports\",\n      \"name\": \"escape\",\n      \"string\": \"exports.escape()\"\n    }\n  }\n]\n```\n\nThis output can then be passed to a template for rendering. Look below at the \"Properties\" section for details.\n\n## Usage\n\n```\n\nUsage: dox [options]\n\n  Options:\n\n    -h, --help                     output usage information\n    -V, --version                  output the version number\n    -r, --raw                      output \"raw\" comments, leaving the markdown intact\n    -a, --api                      output markdown readme documentation\n    -s, --skipPrefixes [prefixes]  skip comments prefixed with these prefixes, separated by commas\n    -d, --debug                    output parsed comments for debugging\n    -S, --skipSingleStar           set to false to ignore `/* ... */` comments\n\n  Examples:\n\n    # stdin\n    $ dox > myfile.json\n\n    # operates over stdio\n    $ dox < myfile.js > myfile.json\n\n```\n\n### Programmatic Usage\n\n``` javascript\n\nvar dox = require('dox'),\n    code = \"...\";\n\nvar obj = dox.parseComments(code);\n\n// [{ tags:[ ... ], description, ... }, { ... }, ...]\n\n```\n\n## Properties\n\n  A \"comment\" is comprised of the following detailed properties:\n\n    - tags\n    - description\n    - isPrivate\n    - isEvent\n    - isConstructor\n    - line\n    - ignore\n    - code\n    - ctx\n\n### Description\n\n  A dox description is comprised of three parts, the \"full\" description,\n  the \"summary\", and the \"body\". The following example has only a \"summary\",\n  as it consists of a single paragraph only, therefore the \"full\" property has\n  only this value as well.\n\n```js\n/**\n * Output the given `str` to _stdout_.\n */\n\nexports.write = function(str) {\n  process.stdout.write(str);\n};\n```\nyields:\n\n```js\ndescription:\n     { full: '<p>Output the given <code>str</code> to <em>stdout</em>.</p>',\n       summary: '<p>Output the given <code>str</code> to <em>stdout</em>.</p>',\n       body: '' },\n```\n\n  Large descriptions might look something like the following, where the \"summary\" is still the first paragraph, the remaining description becomes the \"body\". Keep in mind this _is_ markdown, so you can indent code, use lists, links, etc. Dox also augments markdown, allowing \"Some Title:\\n\" to form a header.\n\n```js\n/**\n * Output the given `str` to _stdout_\n * or the stream specified by `options`.\n *\n * Options:\n *\n *   - `stream` defaulting to _stdout_\n *\n * Examples:\n *\n *     mymodule.write('foo')\n *     mymodule.write('foo', { stream: process.stderr })\n *\n */\n\nexports.write = function(str, options) {\n  options = options || {};\n  (options.stream || process.stdout).write(str);\n};\n```\n\nyields:\n\n```js\ndescription:\n     { full: '<p>Output the given <code>str</code> to <em>stdout</em><br />or the stream specified by <code>options</code>.</p>\\n\\n<h2>Options</h2>\\n\\n<ul>\\n<li><code>stream</code> defaulting to <em>stdout</em></li>\\n</ul>\\n\\n<h2>Examples</h2>\\n\\n<pre><code>mymodule.write(\\'foo\\')\\nmymodule.write(\\'foo\\', { stream: process.stderr })\\n</code></pre>',\n       summary: '<p>Output the given <code>str</code> to <em>stdout</em><br />or the stream specified by <code>options</code>.</p>',\n       body: '<h2>Options</h2>\\n\\n<ul>\\n<li><code>stream</code> defaulting to <em>stdout</em></li>\\n</ul>\\n\\n<h2>Examples</h2>\\n\\n<pre><code>mymodule.write(\\'foo\\')\\nmymodule.write(\\'foo\\', { stream: process.stderr })\\n</code></pre>' }\n```\n\n### Tags\n\n  Dox also supports JSdoc-style tags. Currently only __@api__ is special-cased, providing the `comment.isPrivate` boolean so you may omit \"private\" utilities etc.\n\n```js\n\n/**\n * Output the given `str` to _stdout_\n * or the stream specified by `options`.\n *\n * @param {String} str\n * @param {{stream: Writable}} options\n * @return {Object} exports for chaining\n */\n\nexports.write = function(str, options) {\n  options = options || {};\n  (options.stream || process.stdout).write(str);\n  return this;\n};\n```\n\nyields:\n\n```js\ntags:\n   [ { type: 'param',\n       string: '{String} str',\n       types: [ 'String' ],\n       name: 'str',\n       description: '' },\n     { type: 'param',\n       string: '{{stream: Writable}} options',\n       types: [ { stream: ['Writable'] } ],\n       name: 'options',\n       description: '' },\n     { type: 'return',\n       string: '{Object} exports for chaining',\n       types: [ 'Object' ],\n       description: 'exports for chaining' },\n     { type: 'api',\n       visibility: 'public' } ]\n```\n\n#### Complex jsdoc tags\n\ndox supports all jsdoc type strings specified in the [jsdoc documentation](http://usejsdoc.org/tags-type.html). You can\nspecify complex object types including optional flag `=`, nullable `?`, non-nullable `!` and variable arguments `...`.\n\nAdditionally you can use `typesDescription` which contains formatted HTML for displaying complex types.\n\n```js\n\n/**\n * Generates a person information string based on input.\n *\n * @param {string | {name: string, age: number | date}} name Name or person object\n * @param {{separator: string} =} options An options object\n * @return {string} The constructed information string\n */\n\nexports.generatePersonInfo = function(name, options) {\n  var str = '';\n  var separator = options && options.separator ? options.separator : ' ';\n\n  if(typeof name === 'object') {\n    str = [name.name, '(', name.age, ')'].join(separator);\n  } else {\n    str = name;\n  }\n};\n```\n\nyields:\n\n```js\ntags:\n[\n  {\n    \"tags\": [\n      {\n        \"type\": \"param\",\n        \"string\": \"{string | {name: string, age: number | date}} name Name or person object\",\n        \"name\": \"name\",\n        \"description\": \"Name or person object\",\n        \"types\": [\n          \"string\",\n          {\n            \"name\": [\n              \"string\"\n            ],\n            \"age\": [\n              \"number\",\n              \"date\"\n            ]\n          }\n        ],\n        \"typesDescription\": \"<code>string</code>|{ name: <code>string</code>, age: <code>number</code>|<code>date</code> }\",\n        \"optional\": false,\n        \"nullable\": false,\n        \"nonNullable\": false,\n        \"variable\": false\n      },\n      {\n        \"type\": \"param\",\n        \"string\": \"{{separator: string} =} options An options object\",\n        \"name\": \"options\",\n        \"description\": \"An options object\",\n        \"types\": [\n          {\n            \"separator\": [\n              \"string\"\n            ]\n          }\n        ],\n        \"typesDescription\": \"{ separator: <code>string</code> }|<code>undefined</code>\",\n        \"optional\": true,\n        \"nullable\": false,\n        \"nonNullable\": false,\n        \"variable\": false\n      },\n      {\n        \"type\": \"return\",\n        \"string\": \"{string} The constructed information string\",\n        \"types\": [\n          \"string\"\n        ],\n        \"typesDescription\": \"<code>string</code>\",\n        \"optional\": false,\n        \"nullable\": false,\n        \"nonNullable\": false,\n        \"variable\": false,\n        \"description\": \"The constructed information string\"\n      }\n    ]\n```\n\n### Code\n\n The `.code` property is the code following the comment block, in our previous examples:\n\n```js\nexports.write = function(str, options) {\n  options = options || {};\n  (options.stream || process.stdout).write(str);\n  return this;\n};\n```\n\n### Ctx\n\n  The `.ctx` object indicates the context of the code block, is it a method, a function, a variable etc. Below are some examples:\n\n```js\nexports.write = function(str, options) {\n};\n```\n\nyields:\n\n```js\nctx:\n { type: 'method',\n   receiver: 'exports',\n   name: 'write',\n   string: 'exports.write()' } }\n```\n\n```js\nvar foo = 'bar';\n```\n\nyields:\n\n```js\nctx:\n { type: 'declaration',\n   name: 'foo',\n   value: '\\'bar\\'',\n   string: 'foo' }\n```\n\n```js\nfunction User() {\n\n}\n```\n\nyields:\n\n```js\nctx:\n { type: 'function',\n   name: 'User',\n   string: 'User()' } }\n```\n\n### Ignore\n\nComments and their associated bodies of code may be flagged with \"!\" to be considered worth ignoring, these are typically things like file comments containing copyright etc, however you of course can output them in your templates if you want.\n\n```\n/**\n * Not ignored.\n */\n```\n\nvs\n\n```\n/*!\n * Ignored.\n */\n```\n\nYou may use `-S`, `--skipSingleStar` or `{skipSingleStar: true}` to ignore `/* ... */` comments.\n\n### Running tests\n\n Install dev dependencies and execute `make test`:\n\n     $ npm install -d\n     $ make test\n\n## License\n\n(The MIT License)\n\nCopyright (c) 2011 TJ Holowaychuk &lt;tj@vision-media.ca&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/visionmedia/dox/issues"
  },
  "_id": "dox@0.7.0",
  "_shasum": "6745129c7a1caedfb26e175a6f21057a4c959705",
  "_resolved": "https://github.com/visionmedia/dox/tarball/master",
  "_from": "https://github.com/visionmedia/dox/tarball/master"
}
